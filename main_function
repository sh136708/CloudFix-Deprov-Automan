import re
import requests
import os
import openai
from dotenv import load_dotenv
from openai import OpenAI
from google.oauth2.service_account import Credentials
import datetime
from datetime import datetime, timezone
import base64
import gspread
from gspread.exceptions import APIError
import json
import time
import boto3
from boto3.dynamodb.conditions import Key
from datetime import datetime, timedelta
import pytz

import mysql.connector
import sys
import logging
from zd_utils import *
import pymysql


#Authentication
...

# Load the environment variables from the .env file
load_dotenv()

# Set the OpenAI API key from the environment variable
openai.api_key = OPENAI_API_KEY
client = openai.OpenAI(api_key=OPENAI_API_KEY)

def lambda_handler(event, context):

    try:    
        ############################################################################################################       
        #### PRE INITIALIZATION ####
        ############################################################################################################    
        
        # Parse the incoming JSON payload
        if 'body' in event:
            body = json.loads(event['body'])
            ticket_number = body.get('ticket_number')
            print('Ticket Number:', ticket_number)
        else:
            raise ValueError("No ticket_number provided in the request body")
        
        #Initialize Old variables
        partition_key_name = 'ticket_number'
        partition_key_value = ticket_number    
        table_name = 'SC_Automan_Reruns'
        status= "Lambda Re-Run Stopped by Dynamo DB Check" # default comment when open sc ==1 or this becomes opening comment for multiopen  sc when open sc>1
        credentials = base64.b64encode(f"ai-zd-integration@trilogy.com/token:{ZENDESK_API_KEY}".encode("utf-8")).decode("utf-8")
        date_time = "0000-00-00T00:00:00.000Z"
        
        #Initialize New variables
        ticketDescription = ""
        response = ""
        extracted_data = {}
        date_str = ""
        cursor = ""
        
        #Determine Current Time
        current_time = datetime.now(timezone.utc).strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z' # Get the current time in UTC
        current_time_str = ''.join(current_time) # Convert the current time to a string
        current_time_new = datetime.fromisoformat(current_time_str.strip('Z')).replace(microsecond=0)
        print('Current Time:', current_time_new)
        
        dynamodb = boto3.client(
            'dynamodb',
            aws_access_key_id=aws_access_key_id,
            aws_secret_access_key=aws_secret_access_key,
            region_name=region_name
        )
        
        ############################################################################################################       
        #### INITIAL FUNCTIONS ####
        ############################################################################################################     
        
        #Function to get the worksheet
        def get_worksheet(gscredentials):
            try:
                gc = gspread.authorize(gscredentials)
                sh = gc.open_by_key('1r-jUET6tchc3GhWGtH2TPDczV-_jKQgF7B6mAY9VbZY')
                worksheet = sh.worksheet('Sheet1')
                return worksheet
            except APIError as e:
                if 'APIError' in str(e):
                    print("Google API error, ignoring...")
                else:
                    raise  # Re-raise the exception if it's not a quota exceeded error
        
        #Function to write to GSHEET
        def write_to_gsheet(gscredentials, current_time, ticket_number, status):
            try:
                worksheet = get_worksheet(gscredentials)
                row_data = [current_time, ticket_number, status]
                worksheet.append_row(row_data)
            except APIError as e:
                if 'APIError' in str(e):
                    print("Google API error, ignoring writing to google sheet and moving on...")
                else:
                    raise  # Re-raise the exception if it's not a quota exceeded error
        
        #Function to Make the ticket Open
        def put_ticket_on_open(credentials, ticket_number):
            headers = {
                "Content-Type": "application/json",
                "Authorization": f"Basic {credentials}"
            }

            jsonBody = {
                "ticket": {
                "status": "open"
                }
            }
            
            update_url = f"https://central-supportdesk.zendesk.com/api/v2/tickets/update_many.json?ids={ticket_number}"
            update_response = requests.put(update_url, headers=headers, json=jsonBody)
            
            if update_response.status_code == 200:
                pass
                #print("PUT API for opening the ticket succeeded")
            else:
                print(f"PUT API for opening the ticket failed: {update_response.status_code}")
                print(f"Response content: {update_response.content}")
        
        #Function to Make the ticket Closed with a Public Comment
        def solve_ticket_with_pr(credentials, ticket_number): #need to modify to pick the text from deproc_pr_customer.txt
            headers = {
                "Content-Type": "application/json",
                "Authorization": f"Basic {credentials}"
            }

            jsonBody = {
                "ticket": {
                "status": "solved",
                "comment": {
                    "body": (
                        "Dear Customer, \n\n Your CF sub account has been successfully deprovisioned. \n\n If you have any further queries, please feel free to reach out to us. \n\n Best Regards, \n\n CloudFix Support Team"
                    ),
                    "public": True
                    }
                }
            }
            
            update_url = f"https://central-supportdesk.zendesk.com/api/v2/tickets/update_many.json?ids={ticket_number}"
            update_response = requests.put(update_url, headers=headers, json=jsonBody)
            
            if update_response.status_code == 200:
                pass
                #print("PUT API for opening the ticket succeeded")
            else:
                print(f"PUT API for opening the ticket failed: {update_response.status_code}")
                print(f"Response content: {update_response.content}")
                
        #Function to Make the ticket Closed with a IN
        def close_ticket_with_in(credentials, ticket_number): #need to modify to pick the text from deproc_pr_customer.txt
            headers = {
                "Content-Type": "application/json",
                "Authorization": f"Basic {credentials}"
            }

            jsonBody = {
                "ticket": {
                "status": "solved",
                "comment": {
                    "body": (
                        "CloudFix Deprov Automan: I found a future deprovisioning date. I have added it to the Follow-Up Scheduler."
                    ),
                    "public": False
                },
                "additional_tags": ["future_expiry_date"]
                }
            }
            
            update_url = f"https://central-supportdesk.zendesk.com/api/v2/tickets/update_many.json?ids={ticket_number}"
            update_response = requests.put(update_url, headers=headers, json=jsonBody)
            
            if update_response.status_code == 200:
                pass
                #print("PUT API for opening the ticket succeeded")
            else:
                print(f"PUT API for opening the ticket failed: {update_response.status_code}")
                print(f"Response content: {update_response.content}")
                
        def get_last_entries(ticket_number, limit=10):
            response = dynamodb.query(
                TableName=table_name,
                KeyConditionExpression= f"{partition_key_name} = :pkval",
                ExpressionAttributeValues={
                    ':pkval': {'S': partition_key_value}
                },
                Limit=limit,
                ScanIndexForward=False,  # To get the latest entries first
                ProjectionExpression='ticket_number, date_time'  # Adjust if your attribute names are different
            )
            return response.get('Items', [])

        def is_ticket_recent(ticket_number, entries, time_limit_seconds=100):
            now = datetime.utcnow().replace(tzinfo=pytz.UTC)
            for entry in entries:
                if entry['ticket_number']['S'] == ticket_number:
                    entry_time = datetime.strptime(entry['date_time']['S'], '%Y-%m-%dT%H:%M:%S.%fZ').replace(tzinfo=pytz.UTC)
                    if (now - entry_time).total_seconds() <= time_limit_seconds:
                        return True
            return False

        def append_entry(ticket_number):
            now = datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%S.%fZ')
            #print(f"Adding item to DynamoDB: ticket_number={ticket_number}, date_time={now}")
            dynamodb.put_item(
                TableName=table_name,
                Item={
                    partition_key_name: {'S': partition_key_value},
                    'date_time': {'S': now}
                }
            )

        ############################################################################################################       
        #### DOUBLE RUN CHECK USING DBB WITH PRE INITIALIZATION ####
        ############################################################################################################     
        
        # Check if the ticket_number exists in the table
        try:
            response = dynamodb.get_item(
                TableName=table_name,
                Key={
                    'ticket_number': {'S': ticket_number},
                    'date_time': {'S': date_time} 
                }
            )
            # Check if the item is found
            if 'Item' in response:
                print("Successfully retrieved item from DynamoDB")
            else:
                print("No item found in DynamoDB for the given ticket_number")
        except dynamodb.exceptions.ResourceNotFoundException:
            print(f"Table {table_name} not found")
        except Exception as e:
            print(f"Error retrieving item: {e}")

        # Proceed with the double run check
        last_entries = get_last_entries('your-partition-key-value')
        if is_ticket_recent(ticket_number, last_entries):
            raise Exception(f"Multiple runs detected for ticket number {ticket_number} and stopped using DBB.")
        else:
            append_entry(ticket_number)
            print(f"Ticket number {ticket_number} has been added. Continuing script.")
        
        ############################################################################################################
        #### MAIN FUNCTIONS ####
        ############################################################################################################     
        
        #Function to get the Scheduler Sheet             
        def get_scheduler_worksheet(gscredentials):
            try:
                gc = gspread.authorize(gscredentials)
                sh = gc.open_by_key('1p2_qDgt8CwL3_hB5vEdKba3XC4TAbm8CL7IOS-lAeEg')
                worksheet = sh.worksheet('Sheet1')
                return worksheet
            except APIError as e:
                if 'APIError' in str(e):
                    print("Google API error When Getting Followup Scheduler sheet")
                else:
                    raise  # Re-raise the exception if it's not a quota exceeded error
        
        #Function to write to Scheduler GSHEET
        def write_to_scheduler_gsheet(gscredentials, ticket_number, followup_update):
            try:
                worksheet = get_scheduler_worksheet(gscredentials)
                row_data = [followup_update, ticket_number, 'CloudFix Deprovisioning Automan', 'Scheduled']
                worksheet.append_row(row_data)
            except APIError as e:
                if 'APIError' in str(e):
                    print("Google API error, writing to scheduler google sheet")
                else:
                    raise  # Re-raise the exception if it's not a quota exceeded error
                
        def add_internal_note_to_ticket(ticket_number, comment="No expiry date found"):
            """
            Adds an internal note to a Zendesk ticket.
            """
            url = f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/comments.json"
            payload = {
                "ticket": {
                    "comment": {
                        "body": comment,
                        "public": False  # Set as internal note (not public)
                    }
                }
            }
        
        def add_tag_to_ticket(ticket_number, tag="Future Expiry Date"):
            url = f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}.json"
            
            # First, get the current ticket details to preserve existing tags
            response = requests.get(url, headers=headers)
            if response.status_code == 200:
                ticket_data = response.json()
                existing_tags = ticket_data["ticket"].get("tags", [])
                
                # Add the new tag if it's not already present
                if tag not in existing_tags:
                    existing_tags.append(tag)
                
                # Prepare updated ticket data
                payload = {
                    "ticket": {
                        "tags": existing_tags
                    }
                }
                
                # Send the update request
                update_response = requests.put(url, headers=headers, json=payload)
                if update_response.status_code == 200:
                    print("Tag added successfully!")
                else:
                    print(f"Failed to add tag. Status code: {update_response.status_code}")
                    print(f"Response: {update_response.text}")
            else:
                print(f"Failed to retrieve ticket details. Status code: {response.status_code}")
                print(f"Response: {response.text}")
                def extract_dates(ticketDescription):
                    date_pattern = r'\b(?:\d{1,2}[-/]\d{1,2}[-/]\d{4}|\d{4}[-/]\d{1,2}[-/]\d{1,2}|(?:\d{1,2}(?:st|nd|rd|th)?\s+(?:Jan(?:uary)?|Feb(?:ruary)?|Mar(?:ch)?|Apr(?:il)?|May|Jun(?:e)?|Jul(?:y)?|Aug(?:ust)?|Sep(?:tember)?|Oct(?:ober)?|Nov(?:ember)?|Dec(?:ember)?)\s+\d{4}|(?:Jan(?:uary)?|Feb(?:ruary)?|Mar(?:ch)?|Apr(?:il)?|May|Jun(?:e)?|Jul(?:y)?|Aug(?:ust)?|Sep(?:tember)?|Oct(?:ober)?|Nov(?:ember)?|Dec(?:ember)?)\s+\d{1,2}(?:st|nd|rd|th)?,\s+\d{4}))\b'
                    dates = re.findall(date_pattern, ticketDescription)
                    return dates

        # def getExpiryDateFromOpenAI(ticketDescription):
        #     try:
        #         openai.api_key = OPENAI_API_KEY
        #         response = openai.ChatCompletion.create(
        #                 model=OPENAI_MODEL,
        #                 messages=[
        #                 {"role": "system", "content": OPENAI_FIND_EXPIRY_DATE_PROMPT},
        #                 {"role": "user", "content": ticketDescription}
        #             ],
        #                 temperature=OPENAI_TEMPERATURE,
        #                 max_tokens=OPENAI_MAX_TOKENS,
        #                 top_p=1,
        #                 frequency_penalty=0,
        #                 presence_penalty=0
        #             )
        #         expiryDate = extract_dates(response['choices'][0]['message']['content'])
        #         return str(expiryDate[0]) if expiryDate else None
        #     except Exception as e:
        #         print("ERROR: Unable to get expiry date from OpenAI", e)
        #         return None

        def is_future_date(date_str):
            date_obj = datetime.strptime(date_str, "%b %d, %Y")  # Ensure correct date format
            return date_obj > datetime.now()

        def deprovision_instance(cursor, company_name):
            cursor.execute(f'SELECT id, company_name FROM tenants WHERE company_name LIKE "%{company_name}%"')
            result = cursor.fetchall()
            print(result)
            if result:
                tenant_id = result[0][0]
                cursor.execute(f"UPDATE tenants SET entitlement_tier = NULL, pricing_plan_id = 4 WHERE id = {tenant_id}")
                result = cursor.fetchall()
                print('updated',result)

                cursor.execute(f'SELECT id, company_name, entitlement_tier, pricing_plan_id FROM tenants WHERE id = {tenant_id}')
                result = cursor.fetchall()
                print("validating", result)
                if result[0][3]==4:
                    return True
                else:
                    return False
                return result  # Potentially return this for further processing
            
        # Get problem description from Zendesk ticket
        def get_ticket_content(ticket_number, include_private=True, max_comments=5):
            # Set up API endpoint URLs for Zendesk ticket comments and info
            url_ticket = f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}.json"
            url_comments = (
                f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/comments.json"
            )

            # Initialize message counter and ticket content
            message_count = 0
            global ticket_content
            ticket_content = ""

            # Initialize variables
            submitter_name = requester_name = subject = created_at = updated_at = "Unknown"

            # Get ticket info
            try:
                data_ticket = api_get(url_ticket)
                
                if data_ticket and "ticket" in data_ticket:
                    # Extract necessary information if available
                    ticket_info = data_ticket["ticket"]
                    from_ticket = ticket_info['via']['source']['from']
                    if len(from_ticket)!=0:
                        print('from',from_ticket)
                        return 200, from_ticket['ticket_number'], "It's a follow up"
                    # print("data ticket info", ticket_info.get('via'))
                    submitter_id = ticket_info.get("submitter_id", "Unknown")
                    submitter_name = get_user_name(submitter_id) if submitter_id != "Unknown" else "Unknown"
                    requester_id = ticket_info.get("requester_id", "Unknown")
                    requester_name = get_user_name(requester_id) if requester_id != "Unknown" else "Unknown"
                    subject = ticket_info.get("subject", "Unknown")
                    created_at = ticket_info.get("created_at", "Unknown")
                    updated_at = ticket_info.get("updated_at", "Unknown")
            except Exception as e:
                logger.info(e)
                return (
                    "500",
                    "An unexpected error occurred while fetching the ticket information.",
                )

            content_header = (
                "SUBJECT: " + subject
                + "\nSUBMITTED BY: " + submitter_name
                + "\nREQUESTED BY: " + requester_name
                + "\nCREATED AT: " + created_at
                + "\nUPDATED AT: " + updated_at
                + "\n\n\n"
            )
            
        def find_description(ticket_number):
            print("Finding description")
            text = ticket_gen_data['ticket'].get('description', None) #response = get_ticket_content(ticket_number, max_comments=1) 
            #print("response",response)
            # if response[2]=="It's a follow up":
            #     response = get_ticket_content(response[1], max_comments=1)
            #     print("response",response)
            # text = response[1].split('Agent internal note:')[1]
            
            # Regex patterns
            date_pattern = r"effective\s([\w]+\s\d{1,2},\s\d{4})"
            product_pattern = r"Product:\s(.+)"
            company_name_pattern = r"Company Name:\s(.+)"
            full_name_pattern = r"Contact Full Name:\s(.+)"
            email_pattern = r"Contact Email:\s([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})"
            cc_pattern = r"CC:\s([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})"

            extracted_data = {
                "date": re.search(date_pattern, text).group(1) if re.search(date_pattern, text) else None,
                "product": re.search(product_pattern, text).group(1) if re.search(product_pattern, text) else None,
                "company_name": re.search(company_name_pattern, text).group(1) if re.search(company_name_pattern, text) else None,
                "full_name": re.search(full_name_pattern, text).group(1) if re.search(full_name_pattern, text) else None,
                "email": re.search(email_pattern, text).group(1) if re.search(email_pattern, text) else None,
                "cc": re.search(cc_pattern, text).group(1) if re.search(cc_pattern, text) else None,
            }
            
            return extracted_data
        
            # Call GPT using file prompt to determine the expiry date if cannot be found
            # if extracted_data['date'] is None:
            #     extracted_data['date'] = getExpiryDateFromOpenAI(text)
         

        ############################################################################################################        
        #### MAIN INITIALIZATION ####
        ############################################################################################################     
        
        # Create a session and authenticate with basic auth
        session = requests.Session()
        credentials = base64.b64encode(f"ai-zd-integration@trilogy.com/token:{ZENDESK_API_KEY}".encode("utf-8")).decode("utf-8")
        session.headers = {
            'Authorization':  f"Basic {credentials}"
        }

        # Make a GET request to retrieve the ticket Brand and Ticket Priority
        response = session.get(f'https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}.json')    
        
        if response.status_code == 200:
            ticket_gen_data = response.json()
        else:
            print(f"Failed to fetch sc data: {response.status_code}")
        
        # Get Ticket Description 
        #ticketDescription = ticket_gen_data['ticket'].get('description', None)
        extracted_data = find_description(ticket_number)
        print("extracted data", extracted_data)
        
        ############################################################################################################        
        #### MAIN LOGIC ####
        ############################################################################################################    
            
        if extracted_data["date"] is None:
            add_internal_note_to_ticket(ticket_number, "CloudFix Deprov Automan: I did not find an expiry date. So I am opening the ticket for a manual review.")
            put_ticket_on_open(credentials, ticket_number)
            
        elif is_future_date(extracted_data["date"]):
            print("future date!")
            # Add a tag to the ticket for future date
            #add_tag_to_ticket(ticket_number, "Future Expiry Date")
            close_ticket_with_in(credentials, ticket_number)
            followup_update = datetime.strptime(extracted_data["date"], "%b %d, %Y").strftime("%m/%d/%Y")
            write_to_scheduler_gsheet(gscredentials, ticket_number, followup_update)
            
            
        else:
            print("deprovisioning")
            logging.basicConfig(level=logging.ERROR)
            try:
                with pymysql.connect(
                    user=DB_USER,
                    password=DB_PASSWORD,
                    host=DB_HOST,
                    port=DB_PORT,
                    database=DB_NAME
                ) as conn:
                    with conn.cursor() as cursor:
                        deprovision_instance(cursor, extracted_data["company_name"])
                        conn.commit()
            except pymysql.MySQLError as err:
                logging.error(f"Database Error: {err}")
            except Exception as err:
                logging.error(f"An unexpected error occurred: {err}")
            solve_ticket_with_pr(credentials, ticket_number)

    
    ##############################################################################################
    #### EXCEPTION HANDLING ####
    ##############################################################################################
    
    except Exception as e:
        if "No ticket_number provided in the request body" in str(e):
            status= "No ticket_number provided in the request body"
            print(f"{str(e)}")
            write_to_gsheet(gscredentials, current_time, ticket_number, status)
            
        
        elif "Multiple runs detected" in str(e):
            status= "Lamda multi-run detected and stopped using DBB."
            print(f"{str(e)}")
            write_to_gsheet(gscredentials, current_time, ticket_number, status)
            
        else:
            print(f"Lamda exception occurred on the ticket {ticket_number}: {str(e)}")
            status= "I encountered a bit of a snag! So, I would leave the ticket open for a manual review by an agent."
            ticket_status = "open"
            write_to_gsheet(gscredentials, current_time, ticket_number, status)
            put_ticket_on_open(credentials, ticket_number)
